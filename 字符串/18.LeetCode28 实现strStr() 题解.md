# LeetCode28 实现strStr() 题解

## 一、题目描述

实现 strStr() 函数。

给你两个字符串 haystack 和 needle ，请你在 haystack 字符串中找出 needle 字符串出现的第一个位置（下标从 0 开始）。如果不存在，则返回  -1 。

提示：

+ 0 <= haystack.length, needle.length <= 5 * 10^4
+ haystack 和 needle 仅由小写英文字符组成



## 二、分析

这是一道字符串匹配的题目，可以暴力求解，但是会超时，也可以使用KMP，Sunday，BM这些经典字符串匹配算法。

### 1. KMP算法

KMP算法本质上是根据相同前缀后缀构建有限状态自动机，根据模式串构建其转移规则的next数组(next数组中的值表示下标i处最长相同前后缀的前缀最后一个字符的下标，所有值初始化为-1, 表示没有相同前后缀)，构建next数组的过程也相当于匹配的过程。

DFA的状态转移过程实际上就是3步：

+ 失配状态转移。
+ 匹配状态转移。
+ 终态判断。



## 三、代码

### 1. KMP算法

```c++
int strStr(string haystack, string needle) {
    int n = needle.size();
    if (n == 0) return 0;
    vector<int> next(n, -1);
    for (int i = 1; i < n; i++) {
        int temp = next[i - 1];
        while (temp != -1 && needle[temp + 1] != needle[i]) temp = next[temp]
        if (needle[temp + 1] == needle[i]) next[i] = temp + 1;
    }
    int len = -1, ind = 0, h = haystack.size();
    while (ind < h) {
        while (len != -1 && haystack[ind] != needle[len + 1]) len = next[len]
        if (haystack[ind] == needle[len + 1]) len++;
        if (len == n - 1) return ind - len;
        ind++;
    }
    return -1;
}
```

