# LeetCode 837 新21点 题解

## 题目描述

爱丽丝参与一个大致基于纸牌游戏 “21点” 规则的游戏，描述如下：

爱丽丝以 0 分开始，并在她的得分少于 K 分时抽取数字。 抽取时，她从 [1, W] 的范围中随机获得一个整数作为分数进行累计，其中 W 是整数。 每次抽取都是独立的，其结果具有相同的概率。

当爱丽丝获得不少于 K 分时，她就停止抽取数字。 爱丽丝的分数不超过 N 的概率是多少？



## 分析

这是一道动态规划类型的问题，但是一开始我不知道如何求解。

起初，准备从概率角度进行分析，显然，爱丽丝获得x分的概率依赖于前面的概率，并且可以认为这个问题具有重叠子问题，可以进行动态规划。

由于这道题目“从哪来”不容易解决，就从“到哪去”来分析。

### 1.思路1

设状态$dp[x]$表示获得x分的概率，从前向后分析，这样子可以得到状态转移方程：
$$
dp[x]=\frac{1}{m} * \sum_{i=x-10}^{x-1}dp[i]
$$
这样子得到的是不正确的结果，这个不正确的答案是$\sum_{i=K+1}^{M}dp[i]$，显而易见，最终的答案一定会包含重复的情况。

**而动态规划的答案应当是最优解，只存在于一个位置。**因此，换个角度，从前向后，也就可以从后向前，我们可以修改状态定义。



### 2.思路2

从后向前分析，设状态$dp[x]$表示从x分开始抽取，最终可以到$K-W$之间的概率，此时状态转移方程是从后往前的：
$$
dp[x]=\frac{1}{m} * \sum_{i=1}^{10}dp[x + i]
$$


## 代码

### 1.没有任何优化的动态规划(最终会超时)

```c++
double new21Game(int N, int K, int W) {
    double ans[N + 2 * W], ret = 0.0;
    memset(ans, 0, sizeof(ans));
    ans[N] = 1;
    for (int i = K; i <= N; i++) ans[i] = 1.0;
    for (int i = K - 1; i >= 0; i--) {
        // 由于这里会用到区间和，所以可以使用后缀和或者滑动数组，下面使用滑动数组进行优化
        for (int j = i + 1; j <= i + W; j++) ans[i] += ans[j];
        ans[i] /= W;
    }
    return ans[0];
}
```



### 2.转移过程中的优化

使用滑动数组进行优化，时间复杂度降低了一个维度。

```c++
double new21Game(int N, int K, int W) {
    double ans[N + 2 * W], temp[N + 2 * W];
    memset(ans, 0, sizeof(ans));
    memset(temp, 0, sizeof(temp));
    for (int i = K; i <= N; i++) ans[i] = 1.0, temp[i] = N - i + 1;
    for (int i = K - 1; i >= 0; i--) {
        ans[i] = temp[i + 1] / W; 
        temp[i] = temp[i + 1] - ans[i + W] + ans[i];
    }
    return ans[0];
}
```





