# LeetCode1620 秋叶收藏集 题解

## 一、题目描述

小扣出去秋游，途中收集了一些红叶和黄叶，他利用这些叶子初步整理了一份秋叶收藏集 leaves， 字符串 leaves 仅包含小写字符 r 和 y， 其中字符 r 表示一片红叶，字符 y 表示一片黄叶。
出于美观整齐的考虑，小扣想要将收藏集中树叶的排列调整成「红、黄、红」三部分。每部分树叶数量可以不相等，但均需大于等于 1。**每次调整操作，小扣可以将一片红叶替换成黄叶或者将一片黄叶替换成红叶**。请问小扣最少需要多少次调整操作才能将秋叶收藏集调整完毕。



## 二、分析

一开始我并没有看出来这是一道动态规划求解的题目，但是这又是一道字符串相关的题目。

一般来说，字符串相关的题目，主要类型有：字符串匹配，子串相关问题，前缀后缀问难题，回文串相关问题，**最后就是与字符串相关的动态规划问题。**

与字符串相关的动态规划问题，通常有区间DP，线性DP等。

**这道题目中的叶子颜色：红色、黄色，而结果分成了红、黄、红三部分，因此，可以将叶子颜色分成3种类别。**这是一种**==对结果类型进行分类从而进行动态规划抉择(or 具有阶段性特征？？)==**的方法，此外**==比较常见的就是每一步有多种决策来进行动态规划==**的类型。

定义状态$dp[i][j]$为$[0..i]$区间内的最后一个元素处于j状态时需要的最小调整操作次数。$j = 0$表示处于前面的红色，$j = 1$表示黄色，$j = 2$表示处于后面的红色。

那么状态转移方程如下：
$$
dp[i][0]=dp[i-1][0]+isYellow(i)\\
dp[i][1]=\min(dp[i-1][0],dp[i-1][1])+isRed(i)\\
dp[i][2]=\min(dp[i-1][1],dp[i-1][2])+isYellow(i)
$$


## 三、代码实现

```c++
#define isRed(c) (c == 'r' ? 1 : 0)
#define isYellow(c) (c == 'y' ? 1 : 0)

int minimumOperations(string leaves) {
    int len = leaves.size();
    int dp[len + 5][3];
    memset(dp, 0, sizeof(dp));
    dp[0][0] = isYellow(leaves[0]);
    dp[1][1] = dp[0][0] + isRed(leaves[1]);
    dp[2][2] = dp[1][1] + isYellow(leaves[2]);
    for (int i = 1; i < len; i++) dp[i][0] = dp[i - 1][0] + isYellow(leaves[i]);
    for (int i = 2; i < len; i++) dp[i][1] = min(dp[i - 1][1], dp[i - 1][0]) + isRed(leaves[i]);
    for (int i = 3; i < len; i++) dp[i][2] = min(dp[i - 1][1], dp[i - 1][2]) + isYellow(leaves[i]);
    return dp[len - 1][2];
}
```

