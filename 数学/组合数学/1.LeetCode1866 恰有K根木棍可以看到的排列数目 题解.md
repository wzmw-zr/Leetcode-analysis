# LeetCode1866 恰有K根木棍可以看到的排列数目 题解

## 一、题目描述

有 n 根长度互不相同的木棍，长度为从 1 到 n 的整数。请你将这些木棍排成一排，并满足从左侧 可以看到 恰好 k 根木棍。从左侧 可以看到 木棍的前提是这个木棍的 左侧 不存在比它 更长的 木棍。

例如，如果木棍排列为 [1,3,2,5,4] ，那么从左侧可以看到的就是长度分别为 1、3 、5 的木棍。
给你 n 和 k ，返回符合题目要求的排列 数目 。由于答案可能很大，请返回对 10^9 + 7 取余 的结果。

**提示：**

- `1 <= n <= 1000`
- `1 <= k <= n`



## 二、分析

### 1. 第一类斯特林数

恰有K根木棍可以看到，意味着这n个木棍可以被分成k组，而每组都是以最长的开头，假设其中一组一共$m$根，那么该组有$(m-1)!$种排列方式，这是圆排列的公式，因此这个问题就转换成了**n个互不相同的元素划分为k个互不区分的圆排列的数量**，这就是第一类斯特林数。

这里是通过第一类斯特林数的递推公式，使用动态规划求解的。

第一类斯特林数的递推公式：
$$
{n\brack k}={n-1\brack k - 1}+(n-1){n-1\brack k}
$$
从动态规划的角度理解的话，设状态为$f(i,j)$表示前i个木棍恰好可以看到j根木棍的方案数，递推公式与第一类斯特林数的一致。



## 三、代码

```c++
const long MOD = 1e9 + 7;

int rearrangeSticks(int n, int k) {
    long dp[n + 1][k + 1];
    memset(dp, 0, sizeof(dp));
    dp[0][0] = 1;
    for (int i = 1; i <= k; i++) {
        for (int j = 1; j <= n; j++) 
            dp[j][i] = (dp[j - 1][i - 1] + ((j - 1) * dp[j - 1][i] % MOD)) % MOD;
    }
    return dp[n][k];
}
```





