# Leetcode 287题解

**题目描述：**

给定一个包含 n + 1 个整数的数组 nums，其数字都在 1 到 n 之间（包括 1 和 n），可知至少存在一个重复的整数。假设只有一个重复的整数，找出这个重复的数。

说明：

不能更改原数组（假设数组是只读的）。
只能使用额外的 O(1) 的空间。
时间复杂度小于 O($n^2$) 。
数组中只有一个重复的数字，但它可能不止重复出现一次。



**分析：**

寻找重复数字最直接的想法就是哈希，但是正常的哈希需要$O(n)$的空间复杂度，即便使用大小为$(n+1)$数组的数字都在1到n之间的这个性质，直接用数组本身通过交换进行哈希，但是这样就违反了不能修改原数组的要求。

但是这里我们可以考虑大小为$(n+1)$数组的数字都在1到n之间的这个性质，这说明从0号位置的数字出发，逐个以此为下标向后推进，必然会存在一个循环。**只要是存在循环的题目，就可以还是用快慢指针的思想来将其转换为追击问题。**

这里数组相当于将记录式链表转换为计算式的链表，正常不要改数组地址，会造成自己映射到自己从而造成错误。



**代码：**

```c++
int findDuplicate(int* nums, int numsSize){
    int p = 0, q = 0, s = 0, t = 0, cnt = 1;
    do {
        p = nums[p];
        q = nums[nums[q]];
    } while (p != q);
    p = nums[p]; 
    while (p != q) p = nums[p], cnt++;
    while (cnt--) t = nums[t];
    while (s != t) s = nums[s], t = nums[t];
    return s;
}
```

