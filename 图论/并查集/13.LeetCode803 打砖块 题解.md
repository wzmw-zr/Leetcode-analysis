# LeetCode803 打砖块 题解

## 一、题目描述

有一个 m x n 的二元网格，其中 1 表示砖块，0 表示空白。砖块 稳定（不会掉落）的前提是：

+ 一块砖直接连接到网格的顶部，或者
+ 至少有一块相邻（4 个方向之一）砖块 稳定 不会掉落时

给你一个数组 hits ，这是需要依次消除砖块的位置。每当消除 hits[i] = (rowi, coli) 位置上的砖块时，对应位置的砖块（若存在）会消失，然后其他的砖块可能因为这一消除操作而掉落。一旦砖块掉落，它会立即从网格中消失（即，它不会落在其他稳定的砖块上）。

返回一个数组 result ，其中 result[i] 表示第 i 次消除操作对应掉落的砖块数目。

注意，消除可能指向是没有砖块的空白位置，如果发生这种情况，则没有砖块掉落。



## 二、分析

我确实一开始分析得到这是一道**与连通性相关**的问题，采用模拟的话，每次打一个砖块，就执行一堂DFS，判断打了砖块之后，其周围砖块是否能够连到网格顶部，但是这样时间复杂度为$O(n^2)$，必然会超时，因此，与连通性相关的问题，思考并查集解法。

> 计算每次击碎砖块而消失的砖块的数量：
>
> + 和顶部相连的砖块不会掉落。
> + 击碎一个砖块，可能使得其它与之连接的转快不再与顶部相连而消失。
> + 消失的砖块数量 = 击碎之前与顶部相连的砖块数 - 击碎之后与顶部相连到1砖块数 - 1.

消除一个砖块的效果: 可能是一个连通分量被分成了两个连通分量。

而并查集的作用是：把两个连通分量合并成一个连通分量。

**因此，==采用逆向思维，反向补上石块，有多少砖块因为补上的这个砖块而与屋顶的砖块相连。==**

+ 根据hits数组，将输入的grid表格中的对应位置设置为0.

+ 每次击碎一个砖块，因为击碎的砖块而掉落的砖块不会再回来。**因此打碎一个砖块，连带掉了其他砖块，这些砖块不会影响后面的砖块，所以才可以进行逆向操作，==不会出现接通上了本来应当在前面被删掉的砖块。==**

+ 按照hits数组的顺序 **倒序地**把砖块补上，当最后一块砖块补上时，可以恢复成刚开始的时候整个二维表格的样子。

  每次补上一个砖块，计算新增的和屋顶连接的砖块个数，因此，这涉及到节点所代表的子树的节点个数，所以是利用到了并查集的按秩优化。

> 并查集的**”按秩优化“**的秩可以有两个意思：
>
> + 以当前节点为根节点的**子树高度(rank)**。
> + 以当前节点为根节点的**子树的节点总数(size)**。
>
> **==路径压缩和按秩优化的子树节点总数可以并存，但是子树高度就不可以了。==**
>
> 路径压缩+子树节点总数信息，就相当于在根节点再增加一颗子树罢了。

> 对于并查集的进一步理解：**==并查集中的每一个点代表一个集合，对一个点的操作就是对一个集合的操作，通过一个点可以获得该点所在集合的信息。==**

在二维数组中，每一点都可以和四个方向的合法点连接，这样子会顺序混乱，因此**==二维数组中的元素通过从上到下，从左到右的顺序进行处理，每次只需要考虑左侧和上侧的元素是否要相连，因为一个点右侧和下侧的点到了对应位置照样会进行连接，不会有重复、遗漏。==**

> 换句话说，初始化并查集中内容，我们只需要对合法点进行左侧和上侧的连通，右侧和下侧的连通交给后面的点进行，这样才不会重复连接，**==否则，节点合并的可能是当前还不完整的连通分量。==**

还有一个可能存在的问题，现在使用了一个”屋顶节点“，但是这个屋顶节点可能在合并过程中被当做其他节点的子结点，这是不能允许的，所以要对合并下标进行判断，保证”屋顶节点“始终为根节点。

## 三、代码

```c++
int dir[4][2] = {1, 0, -1, 0, 0, 1, 0, -1};

struct UnionSet {
    int n;
    vector<int> fa;
    vector<int> sz;
    UnionSet() = default;
    UnionSet(int n) : n(n), fa(n), sz(n) {
        for (int i = 0; i < n; i++) {
            fa[i] = i;
            sz[i] = 1;
        }
    }
    int get(int x) {
        return fa[x] = (x == fa[x] ? x : get(fa[x]));
    }
    void merge(int x, int y) {
        int a = get(x);
        int b = get(y);
        if (a == b) return ;
        // 因为要保证0节点不能是其他节点的子结点。
        if (a < b) {
            fa[b] = a;
            sz[a] += sz[b];
        } else {
            fa[a] = b;
            sz[b] += sz[a];
        }
    }
    int size(int x) {
        return sz[get(x)];
    }
};

vector<int> hitBricks(vector<vector<int>>& grid, vector<vector<int>>& hits) {
    int h = grid.size(), w = grid[0].size();
    auto status = grid;
    for (auto &x : hits) status[x[0]][x[1]] = 0;
    UnionSet u(h * w + 1);
    for (int i = 0; i < h; i++) {
        for (int j = 0; j < w; j++) {
            if (status[i][j] == 0) continue;
            if (i == 0) u.merge(0, i * w + j + 1);
            // 保证节点连通的是相对完整的连通分量，只需要对上侧和左侧进行连接，因为那些部分是完整的。
            if (i > 0 && status[i - 1][j]) u.merge((i - 1) * w + j + 1, i * w + j + 1);
            if (j > 0 && status[i][j - 1]) u.merge(i * w + j, i * w + j + 1);
        }
    }
    vector<int> ans(hits.size(), 0);
    for (int i = hits.size() - 1; i >= 0; i--) {
        int x = hits[i][0], y = hits[i][1];
        if (!grid[x][y]) {
            ans.push_back(0);
            continue;
        }
        int pre = u.size(0);
        if (x == 0) u.merge(0, y + 1); // 如果打碎的是最上层的节点，那么就需要与”屋顶节点“进行连接。
        for (int i = 0; i < 4; i++) {
            int x_t = x + dir[i][0]; 
            int y_t = y + dir[i][1];
            if (x_t < 0 || x_t >= h || y_t < 0 || y_t >= w || !status[x_t][y_t]) continue;
            u.merge(x * w + y + 1, x_t * w + y_t + 1);
        }
        ans[i] = max(0, u.size(0) - pre - 1);
        status[x][y] = 1;
    }
    return ans;
}
```

