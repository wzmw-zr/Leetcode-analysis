# LeetCode72 编辑距离 题解

## 一、题目描述

给你两个单词 word1 和 word2，请你计算出将 word1 转换成 word2 所使用的最少操作数 。

你可以对一个单词进行如下三种操作：

1. 插入一个字符
2. 删除一个字符
3. 替换一个字符



## 二、分析

**编辑距离(Edit Distance)，又称Levenshtein距离，是指两个字符串之间，由一个转成另一个所需的最小编辑操作次数。**这是一道**经典的动态规划问题**。

编辑距离算法在数据科学中应用广泛，是用作机器翻译和语音识别标准的基本算法。

我们可以对任意一个单词进行三种操作：

+ 插入一个字符
+ 删除一个字符
+ 替换一个字符

题目中给定了两个单词，设为A和B，这样我们就有六种操作方法，但是本质上不同的操作只有三种：

+ 在单词A中插入一个字符(等价于在B中删除一个字符)
+ 在单词B中插入一个字符(等价于在A中删除一个字符)
+ 修改单词A中的一个字符(等价于修改B中的一个字符)

这样，我们就可以将原问题转化为规模较小的子问题，以`A=horse,B=ros`作为例子：

+ **在单词A中插入一个字符**：假设我们知道`horse`到`ro`的编辑距离为a，那么显然`horse`到`ros`的编辑距离不会超过a + 1。因为我们可以在a次操作之后将`horse`和`ro`变成相同的字符串，只需要额外的一次操作，在单词A的末尾加上字符s，我们就能在`a+1`次操作之后将`horse`和`ros`变成相同的字符串。
+ **在单词B中插入一个字符**：假设我们知道`hors`到`ros`的编辑距离为b，那么显然`horse`到`ros`的编辑距离不会超过b + 1，原因同上。
+ **修改单词A中的一个字符**：假设我们知道`hors`到`ro`的编辑距离为c，那么显然`horse`到`ros`的编辑距离不会超过c + 1，原因同上。

那么从`horse`变成`ros`的编辑距离应该为$\min(a+1,b+1,c+1)$。

> 实际上这种多操作决策的问题，本身就具有使用动态规划的特征，因为这是必然可以使用深度优先搜索的。而这种**==多决策问题的关键在于进行了某种决策时，其最优值应当是从之前的哪一种状态转移而来的。==**

因此，我们定义状态$dp[i][j]$为A的前i个字符和B的前j个字符之间的编辑距离，状态转移方程如下：

+ 如果$A[i]=B[j]$，则$dp[i][j]=\min(dp[i-1][j],dp[i][j-1],dp[i-1][j-1]-1)+1$。
+ 如果$A[i]\neq B[j]$，则$dp[i][j]=\min(dp[i-1][j],dp[i][j-1],dp[i-1][j-1])+1$。



## 三、代码

```c++
int minDistance(string word1, string word2) {
    int len_1 = word1.size(), len_2 = word2.size();
    vector<vector<int>> dp(len_1 + 5, vector<int>(len_2 + 5, 0));
    for (int i = 1; i <= len_2; i++) dp[0][i] = i;
    for (int i = 1; i <= len_1; i++) dp[i][0] = i;
    for (int i = 1; i <= len_1; i++) {
        for (int j = 1; j <= len_2; j++) {
            if (word1[i - 1] == word2[j - 1]) dp[i][j] = min(dp[i - 1][j - 1] - 1, min(dp[i - 1][j], dp[i][j - 1])) + 1;
            else dp[i][j] = min(dp[i - 1][j - 1], min(dp[i - 1][j], dp[i][j - 1])) + 1;
        }
    }
    return dp[len_1][len_2];
}
```

