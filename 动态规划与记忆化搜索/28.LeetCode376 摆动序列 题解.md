# LeetCode376 摆动序列 题解

## 一、题目描述

如果连续数字之间的差严格地在正数和负数之间交替，则数字序列称为摆动序列。第一个差（如果存在的话）可能是正数或负数。少于两个元素的序列也是摆动序列。

例如， [1,7,4,9,2,5] 是一个摆动序列，因为差值 (6,-3,5,-7,3) 是正负交替出现的。相反, [1,4,7,2,5] 和 [1,7,4,5,5] 不是摆动序列，第一个序列是因为它的前两个差值都是正数，第二个序列是因为它的最后一个差值为零。

给定一个整数序列，返回作为摆动序列的最长子序列的长度。 通过从原始序列中删除一些（也可以不删除）元素来获得子序列，剩下的元素保持其原始顺序。



## 二、分析

### 1.动态规划

因为这是一道**涉及子序列的题目，动态规划往往是求解子序列问题的方法，一般来说，涉及到子序列的动态规划多为线性DP或者区间DP，这里线性DP即可。**

首先求得相邻数字之间的差值数组$dif$，设$dp[i]$为$[0,i]$的的差值数组下标区间内的以$dif[i]$结尾的最长的序列长度，状态转移方程为：

``` c++
for (int j = 0; j < i - 1; j++) {
    if ((dif[i] > 0 && dif[j] < 0) || (dif[i] < 0 && dif[j] > 0)) dp[i] = max(dp[i], dp[j] + 1)
}
```

**需要注意数组长度为0和1的情况，也需要注意相邻的数字相同导致相邻数字的差值为0的情况，这就要求一开始的最大长度设为0。**

不过这个方法的空间复杂度是$O(n)$，时间复杂度是$O(n^2)$。



### 二、优化后的动态规划

可以发现，这是一道**具有”峰谷“特征的题目**，而这类题目通常都可以进行优化，达到线性时间复杂度。

约定：

1. 某个序列被称为「上升摆动序列」，当且仅当该序列是摆动序列，且最后一个元素呈上升趋势。
2. 某个序列被称为「下降摆动序列」，当且仅当该序列是摆动序列，且最后一个元素呈下降趋势。
3. 对于长度为 1 的序列，它既是「上升摆动序列」，也是「下降摆动序列」。
4. 序列中的某个元素被称为「峰」，当且仅当该元素两侧的相邻元素均小于它。
5. 序列中的某个元素被称为「谷」，当且仅当该元素两侧的相邻元素均大于它。
6. 特别地，对于位于序列两端的元素，只有一侧的相邻元素小于或大于它，我们也称其为「峰」或「谷」。

每当我们选择一个元素作为摆动序列的一部分时，这个元素要么是上升的，要么是下降的，这取决于前一个元素的大小。

设状态：

1. `up[i]`表示**前i个元素中的==某一个为结尾==的最长的上升摆动序列的长度**。
2. `down[i]`表示**前i个元素中==某一个为结尾==的最长的下降摆动序列的长度**。

以`up[i]`为例，说明其状态转移规则：

1. 当`nums[i] <= nums[i - 1]`，我们无法选出更长的上升摆动序列的方案，因为对任何以`nums[i]`结尾的上升摆动序列，我们都可以将`nums[i]`替换为`nums[i-1]`，使其成为以`nums[i-1]`结尾的上升摆动序列。

2. 当`nums[i] > nums[i - 1]`时，我们既可以从`up[i - 1]`进行转移，也可以从`down[i - 1]`进行转移。从`down[i - 1]`转移必然是合法的，即必然存在一个`down[i - 1]`对应的最长的下降摆动序列的末尾元素小于`nums[i]`。

   > 我们记这个末尾元素在原序列中的下标为j，假设j往前的第一个谷为`nums[k]`，我们总可以将`j`移动到`k`，使得这个最长的下降摆动序列的末尾元素为谷。
   >
   > 可以用反证法证明在这个末尾元素为谷的情况下，这个末尾元素必然是从`nums[i]`往前的第一个谷。

对`down[i]`同理，因此状态转移方程为：
$$
up[i]=
\left\{
\begin{aligned}
&up[i-1],\quad &nums[i]\le nums[i - 1]\\
&\max(up[i-1],down[i-1]+1),\quad &nums[i]>nums[i -1]
\end{aligned}
\right.\\
down[i]=
\left\{
\begin{aligned}
&down[i-1],\quad &nums[i]\ge nums[i - 1]\\
&\max(up[i-1]+1,down[i-1]),\quad &nums[i]<nums[i -1]
\end{aligned}
\right.
$$


## 三、代码

### 1.动态规划

```c++
int wiggleMaxLength(vector<int>& nums) {
    int n = nums.size();
    if (n == 0) return 0; 
    if (n == 1) return 1;
    vector<int> dif;
    for (int i = 0; i < n - 1; i++) dif.push_back(nums[i + 1] - nums[i]);
    vector<int> len(n, 1);
    int ans = 0;
    for (int i = 1; i < n - 1; i++) {
        if (dif[i] == 0) continue;
        for (int j = 0; j < i; j++) {
            if ((dif[i] > 0 && dif[j] < 0) || (dif[i] < 0 && dif[j] > 0)) len[i] = max(len[i], len[j] + 1);
        }
        ans = max(ans, len[i]);
    }
    return ans + 1;
}
```



### 2.优化后的动态规划

```c++
int wiggleMaxLength(vector<int>& nums) {
    int n = nums.size();
    if (n < 2) return n;
    vector<int> up(n, 1), down(n, 1);
    for (int i = 1; i < n; i++) {
        if (nums[i] > nums[i - 1]) up[i] = max(up[i - 1], down[i - 1] + 1);
        else up[i] = up[i - 1];
        if (nums[i] < nums[i - 1]) down[i] = max(down[i - 1], up[i - 1] + 1);
        else down[i] = down[i - 1];
    }
    return max(up[n - 1], down[n - 1]);
}
```

当然，还可以继续优化，使得空间复杂度降到$O(1)$。