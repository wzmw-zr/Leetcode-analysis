# LeetCode5756 两个数组最小的异或值之和 题解

## 一、题目描述

给你两个整数数组 nums1 和 nums2 ，它们长度都为 n 。

两个数组的 异或值之和 为 (nums1[0] XOR nums2[0]) + (nums1[1] XOR nums2[1]) + ... + (nums1[n - 1] XOR nums2[n - 1]) （下标从 0 开始）。

比方说，[1,2,3] 和 [3,2,1] 的 异或值之和 等于 (1 XOR 3) + (2 XOR 2) + (3 XOR 1) = 2 + 0 + 2 = 4 。
请你将 nums2 中的元素重新排列，使得 异或值之和 最小 。

请你返回重新排列之后的 异或值之和 。

提示：

+ n == nums1.length
+ n == nums2.length
+ 1 <= n <= 14
+ 0 <= nums1[i], nums2[i] <= 107



## 二、分析

### 1. 暴力枚举

暴力枚举nums2的所有排列，但是时间复杂度很明显是$O(N\times N!)$级别的，必然会超时 。

> 可以调用库里的`next_permuation`，也可以自己写一个`next_permutation`。



### 2. 记忆化深度优先搜索

实际上，状态压缩动态规划通常用来将时间复杂度为$O(N!)$的问题转化为$O(N2^N)$的问题进行求解。

而状态压缩动态规划需要压缩的状态，通常可以通过深度优先搜索求得，可以在深度优先搜索的基础上加上记忆化，如果对记忆化的状态进行编码压缩表示，就是状态压缩动态规划。

> 一般来说，状态的定义的选择上通常会选择一个能够按顺序推进的方式。(这句话意会即可。。。)

我们可以定义nums2数组的已经选择的元素作为状态的一部分，这个状态量可以使用一个check数组表示。而这正是可以运用状态压缩的地方，如果使用状态压缩的话，这个使用比较经典的二进制状态压缩就行。

> nums1前i个元素的和nums2中某个check状态的最小异或和，最后一个元素和check状态中的某一个元素异或，nums1的前(i - 1)个元素和check状态剩下的元素的最小异或和，两者和的最小值。



### 3. 状态压缩动态规划

正如上面所说，使用二进制状态压缩即可，同时注意，二进制状态压缩的压缩状态从小到大枚举就行，因为一个状态的子状态一定在前面出现过了。



## 三、代码

### 1. 状态压缩动态规划

**==需要注意运算符优先级，^符号优先级比+低。。。==**

```c++
int minimumXORSum(vector<int>& nums1, vector<int>& nums2) {
    int n = nums1.size();
    int dp[n + 1][(1 << n) + 1];
    memset(dp, 0x3f, sizeof(dp));
    dp[0][0] = 0;
    for (int i = 1; i <= n; i++) {
        for (int mask = 1; mask < (1 << n); mask++) {
            if (__builtin_popcount(mask) != i) continue;
            for (int j = 0; j < n; j++) {
                if (!(mask & (1 << j))) continue;
                dp[i][mask] = min(dp[i][mask], dp[i - 1][mask - (1 << j)] + (nums1[i - 1] ^ nums2[j]));
            }
        }
    }
    return dp[n][(1 << n) - 1];
}
```

