# LeetCode5639 完成所有工作的最短时间 题解

## 一、题目描述

给你一个整数数组 jobs ，其中 jobs[i] 是完成第 i 项工作要花费的时间。

请你将这些工作分配给 k 位工人。所有工作都应该分配给工人，且每项工作只能分配给一位工人。工人的 工作时间 是完成分配给他们的所有工作花费时间的总和。请你设计一套最佳的工作分配方案，使工人的 **最大工作时间** 得以 **最小化** 。

返回分配方案中尽可能 **最小 的 最大工作时间** 。



## 二、分析

### 1.二分答案+暴力搜索

因为涉及”最小。。。。最大。。。“，所以考虑使用**二分答案**解法，二分的对象是最大工作时间。之后就是在检查是否有方案的最大工作时间小于这个最大工作时间，但是会超时。

### 2.状压DP

> 状压DP适合解决决策时可以随机选，但是选了之后可选项减少，即时间复杂度是$O(N!)$的倍数的题目。

动态规划的复杂度由决策和状态数决定，**==每次可以决策的是选择哪个工作进行分配，分配给谁。==**而决策选择哪个工作进行分配的话，就是工作的集合的状态来作为状态，选择任务是选了之后不能再选，所以决策选择的任务集合中的元素需要全部计算出来。

> **==决策过程中不能重复选择的情况适合状压DP。==**

而因为每次决策选择某个任务之后，需要再次进行决策，这项任务分配给谁，**此时==所有人(或者说可能有多个人)都可以被选择==**，**==这种情况适合带线性性质的动态规划的二维DP(仅仅是形式上的，因为还有其他类型的动态规划体现为二维)==。**但是这里还有前一个决策，所以再加一维。

设jobs的长度为N，可以使用$[0,2^N]$之间的整数代表jobs的任意一个子集，令$tot[i]$代表子集$i$的工作总时间，因此：
$$
tot[i]=tot[i-(1<<j)]+jobs[j]
$$
设$dp[j][i]$表示：前j个工人为了完成作业子集i，需要花费的最大工作时间的最小值。

由于前j个工人完成了任务子集i，因此第j个工人必然完成了i的某个子集s，而其余的工人完成子集$i-s$需要花费的最大工作时间的最小值为$dp[j-1][i-s]$，因此工人j的工作时间为$tot[s]$，因此此时最大工作时间的最小值为$\max\{dp[j-1][i-s],tot[s]\}$。

因此，遍历所有的子集，并求出全局的最小值：
$$
dp[j][i]=\min_{s\subseteq i}(\max\{dp[j-1][i-s],tot[s]\})
$$
最终，$dp[k-1][(1<<N)-1]$即为答案。



## 三、代码

```c++
int minimumTimeRequired(vector<int>& jobs, int k) {
    int n = jobs.size();
    vector<int> tot(1 << n, 0);
    for (int i = 0; i < (1 << n); i++) {
        for (int j = 0; j < n; j++) {
            if ((i & (1 << j)) == 0) continue;
            int left = i - (1 << j);
            tot[i] = tot[left] + jobs[j]; // 集合对应的时间是唯一的，只要求一次就行
            break;
        }
    }

    vector<vector<int>> dp(k, vector<int>(1 << n, -1));
    for (int i = 0; i < (1 << n); i++) dp[0][i] = tot[i]; // 初始化
    
    for (int j = 1; j < k; j++) {
        // 便利所有状态集合
        for (int i = 0; i < (1 << n); i++) {
            int mmin = INT32_MAX;
            // 遍历状态集合i的所有子集
            for (int s = i; s; s = (s - 1) & i) {
                int left = i - s;
                int val = max(dp[j - 1][left], tot[s]);
                mmin = min(mmin, val);
            }
            dp[j][i] = mmin;
        }
    }
    return dp[k - 1][(1 << n) - 1];
}
```

